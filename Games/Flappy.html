<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Bird</title>
  <link rel="icon" type="image/png" href="Images/Flappy.png"/>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100vh;
      background: url('Images/Sky.jpg') center/cover no-repeat;
      overflow: hidden; font-family: sans-serif;
    }
    #game {
      position: relative; width: 100vw; height: 100vh; overflow: hidden;
    }
    #viewport {
      position: absolute; width: 100%; height: 100%; overflow: hidden;
    }
    #hitboxCanvas {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 25;
    }
    .pipe-set {
      position: absolute; top: 0; transform: scale(0.8); transform-origin: top left; width: 200px;
    }
    .pipe-wrapper {
      position: relative; width: 200px;
    }
    .pipe {
      width: 200px; display: block;
    }
    .top-extension, .bottom-extension {
      position: absolute; left: 0; width: 200px;
      height: 700px;
    }
    .top-extension { bottom: 100%; }
    .bottom-extension { top: 100%; }

    #bird {
      position: absolute; width: 75px; height: auto; left: 50%; transform: translateX(-50%);
      z-index: 10;
    }
    #score {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      font-size: 32px; color: white; text-shadow: 1px 1px 3px black; z-index: 20;
    }
    #game-over {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.6); display: none; flex-direction: column;
      align-items: center; justify-content: center; color: white; font-size: 36px;
      z-index: 30;
    }
    #game-over button {
      font-size: 24px; margin-top: 20px; padding: 10px 20px; cursor: pointer;
    }
    #controls {
      position: absolute; top: 20px; left: 20px; z-index: 50;
      background: rgba(0,0,0,0.5); color: white; padding: 10px; border-radius: 8px;
    }
  </style>
</head>
<body>

<div id="game">
  <div id="viewport"></div>
  <canvas id="hitboxCanvas"></canvas>
  <img id="bird" src="Images/Bird.png" alt="Bird" />
  <div id="score">Score: 0</div>
  <div id="game-over">
    Game Over<br />
    <button onclick="restartGame()">Restart</button>
  </div>
  <div id="controls">
    <label><input type="checkbox" id="showBirdHitbox"> Bird Hitbox</label><br>
    <label><input type="checkbox" id="showPipeHitbox"> Pipe Hitboxes</label>
  </div>
</div>

<script>
  const viewport = document.getElementById('viewport');
  const bird = document.getElementById('bird');
  const scoreEl = document.getElementById('score');
  const gameOverScreen = document.getElementById('game-over');
  const hitboxCanvas = document.getElementById('hitboxCanvas');
  const ctx = hitboxCanvas.getContext('2d');

  const showBirdHitbox = document.getElementById('showBirdHitbox');
  const showPipeHitbox = document.getElementById('showPipeHitbox');

  const pipeWidth = 200;
  const pipeHeight = 200;
  const extensionHeight = 100;
  const gap = 235;
  const scale = 0.8;
  const spawnInterval = 4500;
  const pipeSpeed = 5;
  const HEIGHT = window.innerHeight;

  const birdHitbox = { offsetX: 0, offsetY: 0, radius: 27 };

  let pipeSets = [];
  let score = 0;

  let birdY = HEIGHT / 2;
  let velocity = 0;
  const gravity = 0.4;
  const jumpStrength = -8;
  let gameRunning = false;
  let gameStarted = false;
  let pipeSpawner = null;
  let startCooldown = false;

  hitboxCanvas.width = window.innerWidth;
  hitboxCanvas.height = window.innerHeight;

  const flapSound = new Audio('Sounds/Flap.mp3');
  const pointSound = new Audio('Sounds/Point.mp3');
  const hitSound = new Audio('Sounds/Hit.mp3');
  const dieSound = new Audio('Sounds/Die.mp3');
  const bgMusic = new Audio('Sounds/flappy.mp3');
  bgMusic.loop = true;
  bgMusic.volume = 0.5;

  function createPipeSet(gapPosition) {
    const container = document.createElement('div');
    container.className = 'pipe-set';

    const topWrapper = document.createElement('div');
    topWrapper.className = 'pipe-wrapper';
    const topPipe = document.createElement('img');
    topPipe.src = 'Images/Pipe2.png';
    topPipe.className = 'pipe';
    const topExt = document.createElement('img');
    topExt.src = 'Images/above-extension.png';
    topExt.className = 'top-extension';
    topWrapper.appendChild(topPipe);
    topWrapper.appendChild(topExt);

    const bottomWrapper = document.createElement('div');
    bottomWrapper.className = 'pipe-wrapper';
    bottomWrapper.style.marginTop = gap + 'px';
    const bottomPipe = document.createElement('img');
    bottomPipe.src = 'Images/Pipe.png';
    bottomPipe.className = 'pipe';
    const bottomExt = document.createElement('img');
    bottomExt.src = 'Images/Pipe-extension.png';
    bottomExt.className = 'bottom-extension';
    bottomWrapper.appendChild(bottomPipe);
    bottomWrapper.appendChild(bottomExt);

    container.appendChild(topWrapper);
    container.appendChild(bottomWrapper);
    viewport.appendChild(container);

    return {
      element: container,
      gapPosition: gapPosition,
      x: window.innerWidth,
      passed: false
    };
  }

  function updatePipePositions() {
    const viewportHeight = window.innerHeight / scale;
    const minY = 50 / scale;
    const maxY = viewportHeight - 50 / scale;

    pipeSets.forEach(pipeSet => {
      const gapY = minY + ((10 - pipeSet.gapPosition) / 10) * (maxY - minY);
      const topY = gapY - (extensionHeight + pipeHeight + gap / 2);
      pipeSet.element.style.left = `${pipeSet.x}px`;
      pipeSet.element.style.top = `${topY}px`;
      pipeSet.gapY = gapY * scale;
    });
  }

  function updateScore() {
    const birdX = window.innerWidth / 2;
    pipeSets.forEach(pipeSet => {
      if (!pipeSet.passed && pipeSet.x + pipeWidth * scale < birdX) {
        pipeSet.passed = true;
        score++;
        scoreEl.textContent = `Score: ${score}`;
        pointSound.currentTime = 0;
        pointSound.play();
      }
    });
  }

  function circleRectCollision(circle, rect) {
    const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
    const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
    const dx = circle.x - closestX;
    const dy = circle.y - closestY;
    return (dx * dx + dy * dy) < (circle.radius * circle.radius);
  }

  function detectCollision() {
    const birdRect = bird.getBoundingClientRect();
    const birdCenter = {
      x: birdRect.left + birdRect.width / 2,
      y: birdRect.top + birdRect.height / 2,
      radius: birdHitbox.radius
    };

    if (birdCenter.y - birdCenter.radius < 0 || birdCenter.y + birdCenter.radius > HEIGHT) {
      dieSound.currentTime = 0;
      dieSound.play();
      endGame();
      return;
    }

    for (const pipeSet of pipeSets) {
      const topPipeImg = pipeSet.element.querySelector('.pipe-wrapper:nth-child(1) .pipe');
      const topExtImg = pipeSet.element.querySelector('.pipe-wrapper:nth-child(1) .top-extension');

      const bottomPipeImg = pipeSet.element.querySelector('.pipe-wrapper:nth-child(2) .pipe');
      const bottomExtImg = pipeSet.element.querySelector('.pipe-wrapper:nth-child(2) .bottom-extension');

      const topRect = topPipeImg.getBoundingClientRect();
      const topExtRect = topExtImg.getBoundingClientRect();
      const bottomRect = bottomPipeImg.getBoundingClientRect();
      const bottomExtRect = bottomExtImg.getBoundingClientRect();

      if (
        circleRectCollision(birdCenter, topRect) ||
        circleRectCollision(birdCenter, topExtRect) ||
        circleRectCollision(birdCenter, bottomRect) ||
        circleRectCollision(birdCenter, bottomExtRect)
      ) {
        hitSound.currentTime = 0;
        hitSound.play();
        endGame();
        return;
      }
    }
  }

  function updateBird() {
    if (!gameRunning) return;

    velocity += gravity;
    birdY += velocity;
    bird.style.top = `${birdY}px`;

    const maxTilt = 25;
    const angle = Math.max(-maxTilt, Math.min(maxTilt, velocity * 3));
    bird.style.transform = `translateX(-50%) rotate(${angle}deg)`;

    detectCollision();
  }

  function drawHitboxes() {
    ctx.clearRect(0, 0, hitboxCanvas.width, hitboxCanvas.height);

    const birdRect = bird.getBoundingClientRect();
    const centerX = birdRect.left + birdRect.width / 2;
    const centerY = birdRect.top + birdRect.height / 2;

    if (showBirdHitbox.checked) {
      ctx.beginPath();
      ctx.arc(centerX + birdHitbox.offsetX, centerY + birdHitbox.offsetY, birdHitbox.radius, 0, 2 * Math.PI);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    if (showPipeHitbox.checked) {
      for (const pipe of pipeSets) {
        const topPipeImg = pipe.element.querySelector('.pipe-wrapper:nth-child(1) .pipe');
        const topExtImg = pipe.element.querySelector('.pipe-wrapper:nth-child(1) .top-extension');
        const bottomPipeImg = pipe.element.querySelector('.pipe-wrapper:nth-child(2) .pipe');
        const bottomExtImg = pipe.element.querySelector('.pipe-wrapper:nth-child(2) .bottom-extension');

        const topRect = topPipeImg.getBoundingClientRect();
        const topExtRect = topExtImg.getBoundingClientRect();
        const bottomRect = bottomPipeImg.getBoundingClientRect();
        const bottomExtRect = bottomExtImg.getBoundingClientRect();

        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.strokeRect(topRect.left, topRect.top, topRect.width, topRect.height);
        ctx.strokeRect(topExtRect.left, topExtRect.top, topExtRect.width, topExtRect.height);
        ctx.strokeRect(bottomRect.left, bottomRect.top, bottomRect.width, bottomRect.height);
        ctx.strokeRect(bottomExtRect.left, bottomExtRect.top, bottomExtRect.width, bottomExtRect.height);
      }
    }
  }

  function gameLoop() {
    if (!gameRunning) return;

    pipeSets.forEach(pipeSet => {
      pipeSet.x -= pipeSpeed;
    });

    while (pipeSets.length > 0 && pipeSets[0].x + pipeWidth * scale < 0) {
      viewport.removeChild(pipeSets[0].element);
      pipeSets.shift();
    }

    updatePipePositions();
    updateBird();
    updateScore();
    drawHitboxes();

    requestAnimationFrame(gameLoop);
  }

  function spawnPipe() {
    if (!gameRunning) return;
    const gapPosition = Math.floor(Math.random() * 6) + 4;
    const pipeSet = createPipeSet(gapPosition);
    pipeSets.push(pipeSet);
  }

  function endGame() {
    gameRunning = false;
    gameOverScreen.style.display = 'flex';
    clearInterval(pipeSpawner);

    bgMusic.pause();
  }
  function startGame() {
    if (startCooldown) return;
    gameStarted = true;
    gameRunning = true;
    gameOverScreen.style.display = 'none';

    bgMusic.currentTime = 0;
    bgMusic.play().catch(() => {});

    if (pipeSpawner) clearInterval(pipeSpawner);
    pipeSpawner = setInterval(spawnPipe, spawnInterval);

    requestAnimationFrame(gameLoop);
  }

  function restartGame() {
    gameRunning = false;
    gameStarted = false;
    startCooldown = true;
    score = 0;
    scoreEl.textContent = 'Score: 0';
    birdY = HEIGHT / 2;
    velocity = 0;
    bird.style.top = `${birdY}px`;
    bird.style.transform = `translateX(-50%) rotate(0deg)`;
    pipeSets.forEach(pipe => viewport.removeChild(pipe.element));
    pipeSets = [];
    gameOverScreen.style.display = 'none';

    clearInterval(pipeSpawner);

    spawnPipe();

    setTimeout(() => {
      startCooldown = false;
    }, 1000);
  }

  function jump() {
    if (!gameStarted) {
      if (startCooldown) return;
      startGame();
      flapSound.currentTime = 0;
      flapSound.play();
      velocity = jumpStrength;
      return;
    }

    if (!gameRunning) return;

    velocity = jumpStrength;
    flapSound.currentTime = 0;
    flapSound.play();
  }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      e.preventDefault();
      jump();
    }
  });

  window.addEventListener('click', jump);

  bird.style.top = `${birdY}px`;
  bird.style.transform = `translateX(-50%) rotate(0deg)`;
  gameRunning = false;
  gameStarted = false;
  startCooldown = false;
</script>

</body>
</html>


